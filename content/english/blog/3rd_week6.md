---
title: "Week 6 (3rd Period) - Localization, 2D Path Planning"
meta_title: ""
description: "meta description for week 6 blog post"
date: 2024-03-24T13:28:00Z
image: "/images/Blog/3rd_week6/cover.png"
categories: ["3rd Period - Weekly Progress"]
authors:
  - "Catarina Caramalho"
  - "Tiago Teixeira"
tags: ["localization", "path planning"]
draft: false
---
#### 3D Localization
<div style="text-align: justify;">

<!-- Ao tentar correr os dois algoritmos em simulação, os estudantes depararam-se com 2 problemas. Primeiro, o MCL3D não é compatível com a arquitetura ARM64, e um dos elementos do grupo possui um computador com esta especificação. O outro problema foi a falta de poder computacional, ou seja, ao correr os algoritmos com o Gazebo e o Rviz abertos, ficava tudo muito lento.  -->
When trying to simulate both algorithms, the students faced two problems. Firstly, MCL3D proved to be incompatible with the ARM64 architecture, and one of the group members had a computer with this specification. The second problem was limited computing power. That is, when running the algorithms with Gazebo and Rviz simultaneously, the system's performance became excessively slow.

<!-- Inicialmente tentou-se ultrapassar este obstaculo utilizando apenas o rviz, no entanto, esta não era uma boa opção, já que verififcar o local onde o robot se encontrava se tornava numa tarefa complicada.
A segunda ideia e a final, foi utilizar um computador remoto, da SocRob@Home, cujo poder computacional é muito superior aos computadores dos elementos da equipa. -->
Initially, it was tried to get over the computational power issue by using Rviz on its own, i.e. without the graphics component (`gazebo_gui:=false`). However, this approach proved unsuitable, since checking the robot's current position was a complicated task. So the solution adopted was to use a remote computer from SocRob@Home, whose computing power is significantly higher than the team members' computers, and which also solved the problem of the computer architecture incompatibility.

<!-- Conseguiu-se assim proceder à iniciliazação dos testes em simulação, onde foram feitos vários testes.
Primeiro decidiu-se traçar a mesma rota com os 2 algoritmos, de modo a que ambos os testes fossem o mais justos possiveis, e isto fez-se porque o MCL3D nao permitia utilizar o Rosbag proveniente da tarefa do Mapping.
Mas rapidamente os estudantes aperceebram se de que isto não era muito preciso, o que os levou a uma nova ideia. Já que o MCL3D não permite correr rosbags, decidiu-se gravar um rosbag enquanto se corria o HDL, e aplicar esse Rosbag no MCL3D, e assim, para ambos os algoritmos o caminho traçado pelo robot foi exatamente o mesmo. -->
Thus, it was time to start the simulation tests, in which various experiments were performed. Firstly, the decision was made to trace the same route manually using both algorithms, in order to guarantee maximum impartiality in the tests. This decision was made because it was impossible for MCL3D to use the Rosbag generated by the Mapping task. However, the students soon realised that this approach did not provide very accurate results, which led them to a new idea. Since the MCL3D didn't support the execution of rosbags, they decided to record a rosbag running this same algorithm and then apply that rosbag to the HDL. This way, the path travelled by the robot was exactly the same for both algorithms, allowing for more precise measurements.
</div>

##### → HDL Localization
<div style="text-align: justify;">

The gif below shows the HDL algorithm being tested in simulation. The red points represents the sensor reading, and the aim is for this area to overlap the map as much as possible. 
</div>

<div class="image-container">
    {{< image 
        src="/images/Blog/3rd_week6/hdl.gif" 
        caption="Figure 1 - HDL Algorithm tested in Simulation" 
        alt="HDL Localization" 
        height="" 
        width="" 
        position="center" 
        command="fill" 
        option="q100" 
        class="img-fluid" 
        title="HDL Localization"  
        webp="false" 
    >}}
</div>

<div style="text-align: justify;">

Visually, HDL shows adequate and consistent behaviour.
<!-- O gif acima ilustra o algoritmo de localização em causa a ser testado em simulação.
A mancha vermelha corresponde ao que o sensor está a captar, e o ideal é que essa mancha se sobreponha o máximo possível ao mapa. Assim, visualmente, o HDL parece ter um comportamento adequado e consistente. -->
</div>

##### → MCL3D
<div style="text-align: justify;">

The image below illustrates MCL3D being tested in simulation.
</div>

<div class="image-container">
    {{< image 
        src="/images/Blog/3rd_week6/mcl3d.gif" 
        caption="Figure 2 - MCL3D Algorithm tested in Simulation" 
        alt="HDL Localization" 
        height="" 
        width="" 
        position="center" 
        command="fill" 
        option="q100" 
        class="img-fluid" 
        title="HDL Localization"  
        webp="false" 
    >}}
</div>

<div style="text-align: justify;">

Based on what has been explained previously, it is clear that this algorithm is not ideal for simulation. It appears to be very unstable and shows constant dislocalizations, meaning that the robot doesn't have a precise idea of its localization.
<!-- O gif acima demonstra o MCL3D a ser testado em simulação, e com base no que já foi previamente explicado, facilmente se compreende que este algoritmo não é de todo o ideal em simulação, já que aparenta ser bastante instável e demosntra deslocalizações constantes, ou seja, o robot não sabe onde está. -->
</div>

#### 2D Path Planning/Guidance
This week, our objective was to modify the [poincloud_to_laserscan node](https://github.com/ros-perception/pointcloud_to_laserscan). The aim was to dynamically adjust the maximum height variable, which sets the limit for the Ouster 3D points used in converting to 2D obstacles. Instead of a static value, we wanted it to be calculated based on the robot's height.

We tried determining the robot's height by using the z-value of the transform from the head frame to the base frame. However, we encountered some errors related to the frames names, which impeded us from obtaining a correct value.

<div class="image-container">
    <div class="image">
        {{< image 
            src="/images/Blog/3rd_week6/robot.png" 
            caption="Figure 3 - Robot Model" 
            alt="Robot Model" 
            height="" 
            width="" 
            position="center" 
            command="fill" 
            option="q100" 
            class="img-fluid" 
            title="Robot Model"  
            webp="false" 
        >}}
    </div>
    <div class="image">
        {{< image 
            src="/images/Blog/3rd_week6/tfs.png" 
            caption="Figure 4 - Robot Frames" 
            alt="Robot Frames" 
            height="" 
            width="" 
            position="center" 
            command="fill" 
            option="q100" 
            class="img-fluid" 
            title="Robot Frames"  
            webp="false" 
        >}}
    </div>
</div>
---
title: "Week 6 (3rd Period) - Localization"
meta_title: ""
description: "meta description for week 6 blog post"
date: 2024-03-24T13:28:00Z
image: "/images/Blog/week5/cover.png"
categories: ["3rd Period - Weekly Progress"]
author: "Catarina Caramalho"
tags: ["localization"]
draft: false
---
#### 3D Localization
<!-- Ao tentar correr os dois algoritmos em simulação, os estudantes depararam-se com 2 problemas. Primeiro, o MCL3D não é compatível com a arquitetura ARM64, e um dos elementos do grupo possui um computador com esta especificação. O outro problema foi a falta de poder computacional, ou seja, ao correr os algoritmos com o Gazebo e o Rviz abertos, ficava tudo muito lento.  -->
When trying to simulate both algorithms, the students faced two problems. Firstly, MCL3D proved to be incompatible with the ARM64 architecture, and one of the group members had a computer with this specification. The second problem was limited computing power. That is, when running the algorithms with Gazebo and Rviz simultaneously, the system's performance became excessively slow.

<!-- Inicialmente tentou-se ultrapassar este obstaculo utilizando apenas o rviz, no entanto, esta não era uma boa opção, já que verififcar o local onde o robot se encontrava se tornava numa tarefa complicada.
A segunda ideia e a final, foi utilizar um computador remoto, da SocRob@Home, cujo poder computacional é muito superior aos computadores dos elementos da equipa. -->
Initially, it was tried to get over the computational power issue by using Rviz on its own, i.e. without the graphics component (`gazebo_gui:=false`). However, this approach proved unsuitable, since checking the robot's current position was a complicated task. So the solution adopted was to use a remote computer from SocRob@Home, whose computing power is significantly higher than the team members' computers, and which also solved the problem of the computer architecture incompatibility.

<!-- Conseguiu-se assim proceder à iniciliazação dos testes em simulação, onde foram feitos vários testes.
Primeiro decidiu-se traçar a mesma rota com os 2 algoritmos, de modo a que ambos os testes fossem o mais justos possiveis, e isto fez-se porque o MCL3D nao permitia utilizar o Rosbag proveniente da tarefa do Mapping.
Mas rapidamente os estudantes aperceebram se de que isto não era muito preciso, o que os levou a uma nova ideia. Já que o MCL3D não permite correr rosbags, decidiu-se gravar um rosbag enquanto se corria o HDL, e aplicar esse Rosbag no MCL3D, e assim, para ambos os algoritmos o caminho traçado pelo robot foi exatamente o mesmo. -->
Thus, it was time to start the simulation tests, in which various experiments were performed. Firstly, the decision was made to trace the same route manually using both algorithms, in order to guarantee maximum impartiality in the tests. This decision was made because it was impossible for MCL3D to use the Rosbag generated by the Mapping task. However, the students soon realised that this approach did not provide very accurate results, which led them to a new idea. Since the MCL3D didn't support the execution of rosbags, they decided to record a rosbag running this same algorithm and then apply that rosbag to the HDL. This way, the path travelled by the robot was exactly the same for both algorithms, allowing for more precise measurements.


##### → HDL Localization
The gif below shows the HDL algorithm being tested in simulation. The red points represents the sensor reading, and the aim is for this area to overlap the map as much as possible. 
<div class="image-container">
        {{< image src="/images/Blog/week6/hdl.gif" caption="Figure 1 - HDL Algorithm tested in Simulation" alt="HDL Localization" height="" width="" position="center" command="fill" option="q100" class="img-fluid" title="HDL Localization"  webp="false" >}}
</div>

Visually, HDL shows adequate and consistent behaviour.
<!-- O gif acima ilustra o algoritmo de localização em causa a ser testado em simulação.
A mancha vermelha corresponde ao que o sensor está a captar, e o ideal é que essa mancha se sobreponha o máximo possível ao mapa. Assim, visualmente, o HDL parece ter um comportamento adequado e consistente. -->


##### → MCL3D
The gif below illustrates MCL3D being tested in simulation. 
<div class="image-container">
        {{< image src="/images/Blog/week6/mcl3d.gif" caption="Figure 2 - MCL3D Algorithm tested in Simulation" alt="HDL Localization" height="" width="" position="center" command="fill" option="q100" class="img-fluid" title="HDL Localization"  webp="false" >}}
</div>

Based on what has been explained previously, it is clear that this algorithm is not ideal for simulation. It appears to be very unstable and shows constant dislocalizations, meaning that the robot doesn't have a precise idea of its localization.
<!-- O gif acima demonstra o MCL3D a ser testado em simulação, e com base no que já foi previamente explicado, facilmente se compreende que este algoritmo não é de todo o ideal em simulação, já que aparenta ser bastante instável e demosntra deslocalizações constantes, ou seja, o robot não sabe onde está. -->


##### Simulation Results
<!-- Ao correr os algoritmos, foi tambem corrido em paralelo um script em python desenvolvido pelos alunos, cujo objetivo é obter os erros face à localização e à orientação de ambos algoritmos, com o fim de comparar numericamente as alternativas.
Os resultados obtidos são os seguintes: -->
During the execution of the algorithms, the students also simultaneously ran a Python script they had developed. The aim of this script is to calculate the localization and orientation errors of both algorithms in order to make a numerical comparison of them. 
The plots of the position errors as a function of time and the orientation errors as a function of time are the following:
<div class="image-container">
    <div class="image">
        {{< image src="/images/Blog/week6/position.png" caption="Figure 3 - Position errors as a function of Time" alt="HDL Localization" height="" width="" position="center" command="fill" option="q100" class="img-fluid" title="HDL Localization"  webp="false" >}}
    </div>
    <div class="image">
        {{< image src="/images/Blog/week6/orientation.png" caption="Figure 4 - Orientation errors as a function of Time" alt="MCL3D" height="" width="" position="center" command="fill" option="q100" class="img-fluid" title="MCL3D"  webp="false" >}}
    </div>
</div>

Note that the time does not start at 0 seconds, because the time that is counted is the ROS time, and the error script is one of the last to be launched.

<!-- Como se observa nos graficos, o HDL é de facto o melhor algoritmo a utilizar em simualçao, contudo, isto não é uma condição suficiente/necessaria para que seja o melhor algoritmo a implemnetar no robot real. 
Durante um teste real, a imprecisão do IMU é superior à da simulação, o que deverá de melhorar o desempenho do MCL3D. Já o HDL, não tem tanto em conta as condições do ambiente real, e portanto, os resultados teoricos poderão ser o oposto dos reais, daí a importancia de correr ambos os algoritmos num ambiente simulado e real. -->
As can be seen in the plots, the maximum position error for the HDL is 0.35m, which contrasts with the maximum of 6m achieved by the MCL3D. With regard to orientation errors, the highest peak was 0.11m for the HDL and 3.1rad for the MCL3D. We can therefore conclude that HDL is indeed the best algorithm to use in simulation. However, this is not a sufficient condition for it to be the best algorithm to be implemented on the real robot. 
During a real test, the inaccuracy of the IMU is higher than that of the simulation, which can improve the performance of MCL3D. On the other hand, HDL doesn't take into account the conditions of the real environment as much, so the theoretical results can be opposite to the real ones. This is why it is essential to test both algorithms in simulated and real environments.
